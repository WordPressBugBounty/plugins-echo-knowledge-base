<?php if ( ! defined( 'ABSPATH' ) ) exit;

/**
 * AI Security and Rate Limiting
 */
class EPKB_AI_Security {

	const RATE_LIMIT_TRANSIENT_PREFIX = 'epkb_ai_chat_rate_';
	const GLOBAL_RATE_LIMIT_TRANSIENT = 'epkb_ai_chat_global_rate';
	const SESSION_COOKIE_NAME = 'epkb_ai_session';
	const SESSION_COOKIE_EXPIRY = 0; // Browser session
	const CHAT_ID_PREFIX = 'chat_';
	
	private $nonce = null;

	/**
	 * Create a new nonce for REST request
	 * @param $force
	 * @return string|null
	 */
	public function get_nonce( $force = false ) {

		if ( !$force && !is_user_logged_in() ) {
			return null;
		}

		if ( isset( $this->nonce ) ) {
			return $this->nonce;
		}

		$this->nonce = wp_create_nonce( 'wp_rest' );

		return $this->nonce;
	}

	/**
	 * REST API nonce verification
	 * rest_nonce = “is this request really from my site?”
	 * Security – proves the request originated from a page generated by your WordPress site (CSRF‑style protection)
	 * Life: 24h max (first 12h return code 1, next 12h return code 2)
	 * where: HTTP header X‑WP‑Nonce (or a restNonce field if the route looks for it)
	 * @param $request
	 * @return mixed
	 */
	public static function check_rest_nonce( $request ) {

		// Validates nonce from X-WP-Nonce header using WordPress nonce system.
		// Returns: false (invalid), 1 (0-12 hours old), or 2 (12-24 hours old)
		$nonce = $request->get_header( 'X-WP-Nonce' );
		$rest_nonce = wp_verify_nonce( $nonce, 'wp_rest' );

		return apply_filters( 'epkb_rest_authorized', $rest_nonce, $request );
	}

	// admins only
	public static function can_access_settings() {
		return apply_filters( 'epkb_allow_configuration', current_user_can( 'manage_options' ) );
	}

	// admins and editors
	public static function can_access_features() {
		$editor_or_admin = current_user_can( 'editor' ) || current_user_can( 'administrator' );
		return apply_filters( 'epkb_allow_features', $editor_or_admin );
	}

	public static function can_access_public_api( $route, $request ) {
		$logged_in = is_user_logged_in();
		return apply_filters( 'epkb_allow_public_api', $logged_in, $route, $request );
	}

	/**
	 * Get session ID from cookie (read-only)
	 * This method only reads existing session, does not create new ones
	 * 
	 * @return string Empty string if no session exists
	 */
	public static function get_session_id() {
		return isset( $_COOKIE[self::SESSION_COOKIE_NAME] ) 
			? sanitize_text_field( $_COOKIE[self::SESSION_COOKIE_NAME] ) 
			: '';
	}
	
	/**
	 * Get or create a session ID
	 * Creates a new session if one doesn't exist and headers haven't been sent
	 * 
	 * @return string Session ID or error
	 */
	public static function get_or_create_session() {
		
		// Check for existing session
		$session_id = self::get_session_id();
		if ( ! empty( $session_id ) ) {
			return $session_id;
		}
		
		// Create new session if possible
		if ( ! headers_sent() && ! wp_doing_cron() && ! defined( 'WP_CLI' ) ) {
			$session_id = self::generate_session_id();
			if ( self::set_session_cookie( $session_id ) ) {
				return $session_id;
			}
		}
		
		// For cron jobs or when headers are sent, return a temporary session ID
		return wp_doing_cron() ? 'wp-cron' : 'N/A';
	}

	/**
	 * Generate a secure session ID
	 *
	 * @return string 32 character hex string
	 */
	public static function generate_session_id() {
		// Try multiple methods for generating secure random data
		$bytes = false;
		
		// Method 1: random_bytes (most secure, PHP 7+)
		if ( function_exists( 'random_bytes' ) ) {
			try {
				$bytes = random_bytes( 16 );
			} catch ( Exception $e ) {
				$bytes = false;
			}
		}
		
		// Method 2: openssl_random_pseudo_bytes (widely compatible, PHP 5.3+)
		if ( $bytes === false && function_exists( 'openssl_random_pseudo_bytes' ) ) {
			$strong = false;
			$bytes = openssl_random_pseudo_bytes( 16, $strong );
			// Only use if cryptographically strong
			if ( ! $strong ) {
				$bytes = false;
			}
		}
		
		// Method 3: Fallback using multiple entropy sources
		if ( $bytes === false ) {
			// Combine multiple sources of entropy
			$entropy = uniqid( '', true );                    // Microsecond precision
			$entropy .= mt_rand();                            // Mersenne Twister
			$entropy .= microtime( true );                    // Current time with microseconds
			$entropy .= serialize( $_SERVER );                // Server variables
			if ( function_exists( 'wp_salt' ) ) {
				$entropy .= wp_salt( 'auth' );                // WordPress salt if available
			}
			
			// Hash the combined entropy
			return substr( hash( 'sha256', $entropy ), 0, 32 );
		}
		
		// Method 4: WordPress's built-in random generation (requires WordPress functions)
		if ( $bytes === false && function_exists( 'wp_generate_password' ) ) {
			// Generate 32 random hex characters using WordPress
			return substr( md5( wp_generate_password( 64, true, true ) . microtime( true ) . uniqid( '', true ) ), 0, 32 );
		}
		
		// Convert bytes to hex string
		return bin2hex( $bytes );
	}
	
	/**
	 * Generate a secure chat ID
	 * 
	 * @param string $prefix Optional prefix for the chat ID (e.g., 'chat_', 'search_')
	 * @return string Prefixed UUID v4 format
	 */
	public static function generate_chat_id( $prefix = self::CHAT_ID_PREFIX ) {
		// Generate a UUID v4 for chat IDs with optional prefix
		return $prefix . EPKB_AI_Utilities::generate_uuid_v4();
	}
	
	/**
	 * Generate a secure idempotency key
	 * 
	 * @return string
	 */
	public static function generate_idempotency_key() {
		// Use UUID v4 format for idempotency keys
		return EPKB_AI_Utilities::generate_uuid_v4();
	}
	
	/**
	 * Set session cookie with security best practices
	 * 
	 * @param string $session_id
	 * @return bool
	 */
	private static function set_session_cookie( $session_id ) {
		
		$cookie_options = array(
			'expires'  => self::SESSION_COOKIE_EXPIRY,
			'path'     => COOKIEPATH ?: '/',
			'domain'   => COOKIE_DOMAIN ?: '',
			'secure'   => is_ssl(),
			'httponly' => true,
			'samesite' => 'Lax'
		);
		
		// PHP 7.3+ supports options array
		if ( version_compare( PHP_VERSION, '7.3.0', '>=' ) ) {
			return setcookie( self::SESSION_COOKIE_NAME, $session_id, $cookie_options );
		}
		
		// Fallback for older PHP versions
		return setcookie( 
			self::SESSION_COOKIE_NAME, 
			$session_id, 
			$cookie_options['expires'],
			$cookie_options['path'],
			$cookie_options['domain'],
			$cookie_options['secure'],
			$cookie_options['httponly']
		);
	}
	
	/**
	 * Validate that a chat ID belongs to the current session
	 * Prevents session hijacking and unauthorized access
	 * 
	 * @param string $chat_id
	 * @param string $session_id Optional, uses current session if not provided
	 * @return bool
	 */
	public static function validate_chat_session( $chat_id, $session_id ) {
		
		if ( empty( $chat_id ) ) {
			return false;
		}
		
		if ( empty( $session_id ) ) {
			$session_id = self::get_session_id();
		}
		
		if ( empty( $session_id ) ) {
			return false;
		}
		
		// Check database for matching chat_id and session_id
		$messages_db = new EPKB_AI_Messages_DB();
		$conversation = $messages_db->get_conversation_by_chat_and_session( $chat_id, $session_id );
		
		return $conversation !== null;
	}

	/**
	 * Decide whether the plugin is allowed to call session_start().
	 *
	 * - checks that a session isn't already started and that it's a safe context to begin one (not during cron or autosave, etc.).
	 * - Essentially, it always returns true (allowing anyone to start a session) unless there's a technical reason not to.
	 * - sets up a cookie and returns a nonce and session ID for the front-end widget to use.
	 *
	 * The goal is to keep PHP sessions *off* for almost every request so that
	 * full‑page caching and other plugins are not affected. We only enable a
	 * session when it is genuinely needed for the epkb REST endpoints.
	 *
	 * @return bool True  → safe to start a session.
	 *              False → do **not** start a session.
	 */
	public static function can_start_session() {

		/*--------------------------------------------------------------------
		 * 1. Abort immediately if a PHP session is already open
		 *------------------------------------------------------------------*/
		if ( session_status() !== PHP_SESSION_NONE ) {
			return false;
		}

		/*--------------------------------------------------------------------
		 * 2. Never open sessions from the command line (WP‑CLI)
		 *------------------------------------------------------------------*/
		/** @disregard P1011 */
		if ( defined( 'WP_CLI' ) && WP_CLI ) {
			return false;
		}

		/*--------------------------------------------------------------------
		 * 3. Skip WordPress internal/background requests
		 *------------------------------------------------------------------*/
		if ( function_exists( 'wp_doing_cron' ) && wp_doing_cron() ) {
			return false;
		}

		if ( defined( 'DOING_AUTOSAVE' ) && DOING_AUTOSAVE ) {
			return false;
		}

		/*--------------------------------------------------------------------
		 * 4. If this is a REST request, allow it ONLY for our namespace (/epkb/)
		 *------------------------------------------------------------------*/
		/** @disregard P1010 */
		if ( function_exists( 'wp_is_serving_rest_request' ) && wp_is_serving_rest_request() ) {
			// Pull the path WordPress saw (query‑var mode) or the raw URI (pretty permalinks)
			$route = $_GET['rest_route'] ?? $_SERVER['REQUEST_URI'] ?? '';

			// Bail out unless the route contains our namespace
			if ( strpos( $route, '/epkb/' ) === false ) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Check if user has exceeded rate limits
	 * 
	 * @param string $user_identifier - Can be user ID or IP hash
	 * @return bool|WP_Error - True if allowed, WP_Error if rate limited
	 */
	public static function check_rate_limit( $user_identifier = '' ) {

		return false; // TODO later

		// Get user identifier
		if ( empty( $user_identifier ) ) {
			$user_identifier = self::get_user_identifier();
		}
		
		// Check global rate limit first
		$global_limit = apply_filters( 'epkb_ai_chat_global_rate_limit', 1000 ); // 1000 requests per hour globally
		$global_count = get_transient( self::GLOBAL_RATE_LIMIT_TRANSIENT );
		
		if ( $global_count >= $global_limit ) {
			return new WP_Error( 'global_rate_limit', __( 'Chat service is temporarily unavailable due to high demand. Please try again later.', 'echo-knowledge-base' ) );
		}
		
		// Check user rate limit
		$user_limit = apply_filters( 'epkb_ai_chat_user_rate_limit', 50 ); // 50 requests per hour per user
		$user_transient = self::RATE_LIMIT_TRANSIENT_PREFIX . $user_identifier;
		$user_count = get_transient( $user_transient );
		
		if ( $user_count >= $user_limit ) {
			return new WP_Error( 'user_rate_limit', __( 'You have reached the chat limit. Please try again in an hour.', 'echo-knowledge-base' ) );
		}
		
		// Increment counters
		set_transient( self::GLOBAL_RATE_LIMIT_TRANSIENT, $global_count + 1, HOUR_IN_SECONDS );
		set_transient( $user_transient, $user_count + 1, HOUR_IN_SECONDS );
		
		return true;
	}
	
	/**
	 * Get unique user identifier for rate limiting
	 * 
	 * @return string
	 */
	private static function get_user_identifier() {
		
		// For logged-in users, use user ID
		if ( is_user_logged_in() ) {
			return 'user_' . get_current_user_id();
		}
		
		// For guests, use hashed IP (GDPR compliant)
		return 'ip_' . hash( 'sha256', self::get_client_ip() . wp_salt() );
	}
	
	/**
	 * Get client IP address
	 * 
	 * @return string
	 */
	private static function get_client_ip() {
		
		$ip_keys = array( 'HTTP_CF_CONNECTING_IP', 'HTTP_CLIENT_IP', 'HTTP_X_FORWARDED_FOR', 'HTTP_X_FORWARDED', 'HTTP_X_CLUSTER_CLIENT_IP', 'HTTP_FORWARDED_FOR', 'HTTP_FORWARDED', 'REMOTE_ADDR' );
		
		foreach ( $ip_keys as $key ) {
			if ( array_key_exists( $key, $_SERVER ) === true ) {
				foreach ( explode( ',', $_SERVER[$key] ) as $ip ) {
					$ip = trim( $ip );
					
					if ( filter_var( $ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE ) !== false ) {
						return $ip;
					}
				}
			}
		}
		
		return isset( $_SERVER['REMOTE_ADDR'] ) ? $_SERVER['REMOTE_ADDR'] : '0.0.0.0';
	}
	
	/**
	 * Sanitize output for display
	 * 
	 * @param string $text
	 * @return string
	 */
	public static function sanitize_output( $text ) {
		
		// Allow basic formatting tags
		$allowed_tags = apply_filters( 'epkb_ai_chat_allowed_tags', array(
			'p' => array(),
			'br' => array(),
			'strong' => array(),
			'em' => array(),
			'u' => array(),
			'ol' => array(),
			'ul' => array(),
			'li' => array(),
			'code' => array(),
			'pre' => array(),
			'blockquote' => array(),
			'a' => array(
				'href' => array(),
				'title' => array(),
				'target' => array(),
				'rel' => array()
			)
		) );
		
		return wp_kses( $text, $allowed_tags );
	}
	
	/**
	 * Log security events
	 * 
	 * @param string $event_type
	 * @param array $data
	 */
	public static function log_security_event( $event_type, $data = array() ) { // TODO
		
		if ( ! apply_filters( 'epkb_ai_chat_log_security_events', true ) ) {
			return;
		}
		
		$log_entry = array(
			'timestamp' => current_time( 'mysql' ),
			'event' => $event_type,
			'ip_hash' => self::get_ip_hash(),
			'user_id' => get_current_user_id(),
			'data' => $data
		);
		
		// Store in transient with 7-day expiration
		$logs = get_transient( 'epkb_ai_chat_security_logs' );
		if ( ! is_array( $logs ) ) {
			$logs = array();
		}
		
		// Keep only last 100 entries
		if ( count( $logs ) >= 100 ) {
			array_shift( $logs );
		}
		
		$logs[] = $log_entry;
		set_transient( 'epkb_ai_chat_security_logs', $logs, WEEK_IN_SECONDS );
	}

	private static function get_ip_hash() {
		return hash( 'sha256', self::get_client_ip() . wp_salt() );
	}
}